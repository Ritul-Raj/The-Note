{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec));\n})(this, function (exports, setArray, sourcemapCodec) {\n  'use strict';\n\n  /**\n   * A low-level API to associate a generated position with an original source position. Line and\n   * column here are 0-based, unlike `addMapping`.\n   */\n  exports.addSegment = void 0;\n  /**\n   * A high-level API to associate a generated position with an original source position. Line is\n   * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n   */\n  exports.addMapping = void 0;\n  /**\n   * Adds/removes the content of the source file to the source map.\n   */\n  exports.setSourceContent = void 0;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  exports.decodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  exports.encodedMap = void 0;\n  /**\n   * Returns an array of high-level mapping objects for every recorded segment, which could then be\n   * passed to the `source-map` library.\n   */\n  exports.allMappings = void 0;\n  /**\n   * Provides the state to generate a sourcemap.\n   */\n  class GenMapping {\n    constructor() {\n      let {\n        file,\n        sourceRoot\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._names = new setArray.SetArray();\n      this._sources = new setArray.SetArray();\n      this._sourcesContent = [];\n      this._mappings = [];\n      this.file = file;\n      this.sourceRoot = sourceRoot;\n    }\n  }\n  (() => {\n    exports.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names\n      } = map;\n      const line = getLine(mappings, genLine);\n      if (source == null) {\n        const seg = [genColumn];\n        const index = getColumnIndex(line, genColumn, seg);\n        return insert(line, index, seg);\n      }\n      const sourcesIndex = setArray.put(sources, source);\n      const seg = name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, setArray.put(names, name)] : [genColumn, sourcesIndex, sourceLine, sourceColumn];\n      const index = getColumnIndex(line, genColumn, seg);\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;\n      insert(line, index, seg);\n    };\n    exports.addMapping = (map, mapping) => {\n      const {\n        generated,\n        source,\n        original,\n        name\n      } = mapping;\n      return exports.addSegment(map, generated.line - 1, generated.column, source, original == null ? undefined : original.line - 1, original === null || original === void 0 ? void 0 : original.column, name);\n    };\n    exports.setSourceContent = (map, source, content) => {\n      const {\n        _sources: sources,\n        _sourcesContent: sourcesContent\n      } = map;\n      sourcesContent[setArray.put(sources, source)] = content;\n    };\n    exports.decodedMap = map => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names\n      } = map;\n      return {\n        version: 3,\n        file,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings\n      };\n    };\n    exports.encodedMap = map => {\n      const decoded = exports.decodedMap(map);\n      return Object.assign(Object.assign({}, decoded), {\n        mappings: sourcemapCodec.encode(decoded.mappings)\n      });\n    };\n    exports.allMappings = map => {\n      const out = [];\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _names: names\n      } = map;\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n          const generated = {\n            line: i + 1,\n            column: seg[0]\n          };\n          let source = undefined;\n          let original = undefined;\n          let name = undefined;\n          if (seg.length !== 1) {\n            source = sources.array[seg[1]];\n            original = {\n              line: seg[2] + 1,\n              column: seg[3]\n            };\n            if (seg.length === 5) name = names.array[seg[4]];\n          }\n          out.push({\n            generated,\n            source,\n            original,\n            name\n          });\n        }\n      }\n      return out;\n    };\n  })();\n  function getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n      mappings[i] = [];\n    }\n    return mappings[index];\n  }\n  function getColumnIndex(line, column, seg) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; i--, index--) {\n      const current = line[i];\n      const col = current[0];\n      if (col > column) continue;\n      if (col < column) break;\n      const cmp = compare(current, seg);\n      if (cmp === 0) return index;\n      if (cmp < 0) break;\n    }\n    return index;\n  }\n  function compare(a, b) {\n    let cmp = compareNum(a.length, b.length);\n    if (cmp !== 0) return cmp;\n    // We've already checked genColumn\n    if (a.length === 1) return 0;\n    cmp = compareNum(a[1], b[1]);\n    if (cmp !== 0) return cmp;\n    cmp = compareNum(a[2], b[2]);\n    if (cmp !== 0) return cmp;\n    cmp = compareNum(a[3], b[3]);\n    if (cmp !== 0) return cmp;\n    if (a.length === 4) return 0;\n    return compareNum(a[4], b[4]);\n  }\n  function compareNum(a, b) {\n    return a - b;\n  }\n  function insert(array, index, value) {\n    if (index === -1) return;\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n  exports.GenMapping = GenMapping;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["exports","addSegment","addMapping","setSourceContent","decodedMap","encodedMap","allMappings","GenMapping","constructor","file","sourceRoot","arguments","length","undefined","_names","setArray","SetArray","_sources","_sourcesContent","_mappings","map","genLine","genColumn","source","sourceLine","sourceColumn","name","mappings","sources","sourcesContent","names","line","getLine","seg","index","getColumnIndex","insert","sourcesIndex","put","mapping","generated","original","column","content","version","array","decoded","Object","assign","sourcemapCodec","encode","out","i","j","push","current","col","cmp","compare","a","b","compareNum","value"],"sources":["D:\\reacttutorial\\awesomeapp\\node_modules\\@jridgewell\\src\\gen-mapping.ts"],"sourcesContent":["import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport let addSegment: {\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source?: null,\n    sourceLine?: null,\n    sourceColumn?: null,\n    name?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name: string,\n  ): void;\n};\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport let addMapping: {\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source?: null;\n      original?: null;\n      name?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name: string;\n    },\n  ): void;\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport let setSourceContent: (map: GenMapping, source: string, content: string | null) => void;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let decodedMap: (map: GenMapping) => DecodedSourceMap;\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let encodedMap: (map: GenMapping) => EncodedSourceMap;\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport let allMappings: (map: GenMapping) => Mapping[];\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private _names = new SetArray();\n  private _sources = new SetArray();\n  private _sourcesContent: (string | null)[] = [];\n  private _mappings: SourceMapSegment[][] = [];\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n  static {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n\n      const line = getLine(mappings, genLine);\n      if (source == null) {\n        const seg: SourceMapSegment = [genColumn];\n        const index = getColumnIndex(line, genColumn, seg);\n        return insert(line, index, seg);\n      }\n\n      // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n      // isn't nullish.\n      assert<number>(sourceLine);\n      assert<number>(sourceColumn);\n      const sourcesIndex = put(sources, source);\n      const seg: SourceMapSegment = name\n        ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name)]\n        : [genColumn, sourcesIndex, sourceLine, sourceColumn];\n\n      const index = getColumnIndex(line, genColumn, seg);\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;\n      insert(line, index, seg);\n    };\n\n    addMapping = (map, mapping) => {\n      const { generated, source, original, name } = mapping;\n      return (addSegment as any)(\n        map,\n        generated.line - 1,\n        generated.column,\n        source,\n        original == null ? undefined : original.line - 1,\n        original?.column,\n        name,\n      );\n    };\n\n    setSourceContent = (map, source, content) => {\n      const { _sources: sources, _sourcesContent: sourcesContent } = map;\n      sourcesContent[put(sources, source)] = content;\n    };\n\n    decodedMap = (map) => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n\n      return {\n        version: 3,\n        file,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n      };\n    };\n\n    encodedMap = (map) => {\n      const decoded = decodedMap(map);\n      return {\n        ...decoded,\n        mappings: encode(decoded.mappings as SourceMapSegment[][]),\n      };\n    };\n\n    allMappings = (map) => {\n      const out: Mapping[] = [];\n      const { _mappings: mappings, _sources: sources, _names: names } = map;\n\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generated = { line: i + 1, column: seg[0] };\n          let source: string | undefined = undefined;\n          let original: Pos | undefined = undefined;\n          let name: string | undefined = undefined;\n\n          if (seg.length !== 1) {\n            source = sources.array[seg[1]];\n            original = { line: seg[2] + 1, column: seg[3] };\n\n            if (seg.length === 5) name = names.array[seg[4]];\n          }\n\n          out.push({ generated, source, original, name } as Mapping);\n        }\n      }\n\n      return out;\n    };\n  }\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], column: number, seg: SourceMapSegment): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; i--, index--) {\n    const current = line[i];\n    const col = current[0];\n    if (col > column) continue;\n    if (col < column) break;\n\n    const cmp = compare(current, seg);\n    if (cmp === 0) return index;\n    if (cmp < 0) break;\n  }\n  return index;\n}\n\nfunction compare(a: SourceMapSegment, b: SourceMapSegment): number {\n  let cmp = compareNum(a.length, b.length);\n  if (cmp !== 0) return cmp;\n\n  // We've already checked genColumn\n  if (a.length === 1) return 0;\n\n  cmp = compareNum(a[1], b[1]!);\n  if (cmp !== 0) return cmp;\n  cmp = compareNum(a[2], b[2]!);\n  if (cmp !== 0) return cmp;\n  cmp = compareNum(a[3], b[3]!);\n  if (cmp !== 0) return cmp;\n\n  if (a.length === 4) return 0;\n  return compareNum(a[4], b[4]!);\n}\n\nfunction compareNum(a: number, b: number): number {\n  return a - b;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  if (index === -1) return;\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}